#pragma kernel CSInit
#pragma kernel TwoNeighborhoods
#pragma kernel ThreeNeighborhoods
#pragma kernel FourNeighborhoods

RWTexture2D<float4> Result;

// Screen variables defined in C# script
uint height;
uint width;


//Neighborhoodbuffers
StructuredBuffer<uint2> NeighborhoodBuffer1;
StructuredBuffer<uint2> NeighborhoodBuffer2;
StructuredBuffer<uint2> NeighborhoodBuffer3;
StructuredBuffer<uint2> NeighborhoodBuffer4;


uint NeighborhoodBuffer1Size;
uint NeighborhoodBuffer2Size;
uint NeighborhoodBuffer3Size;
uint NeighborhoodBuffer4Size;


//RandomDataBuffer
StructuredBuffer<uint> RandomDataBuffer0;
StructuredBuffer<uint> RandomDataBuffer1;
StructuredBuffer<uint> RandomDataBuffer2;
StructuredBuffer<uint> RandomDataBuffer3;


// Mouse interactions
float mousePosX;
float mousePosY;
bool clickedLeft;
bool clickedRight;

// RANDOM float generator 0-1

float remapRange(uint number){
    return float(number)/127.0f;
}


float4 get4ValuesOutOf32Bits(uint data){
    uint mask= 0x7F;
    float4 result;

    result[0]=(remapRange(data & mask)); //127 is 1111111 in binary and 7F in hex
    result[1]=(remapRange((data>>7)& mask));
    result[2]=(remapRange((data>>14)& mask));
    result[3]=(remapRange((data>>21)& mask));

    return result;
}



struct thresholdsArray{
    float thresholds[32];
};


void SetThresholds(inout thresholdsArray thArray, StructuredBuffer<uint> data){
    for(uint i= 0; i<32; i+=4){
        float4 addToArray=get4ValuesOutOf32Bits(data[i]);
        thArray.thresholds[i]=addToArray.r;
        thArray.thresholds[i+1]=addToArray.g;
        thArray.thresholds[i+2]=addToArray.b;
        thArray.thresholds[i+3]=addToArray.a;

    }
}

struct outputValueArray{
    int outputValArray[16];
};

void SetOutputValueArray(inout outputValueArray valArray, StructuredBuffer<uint> data){
    for(uint i=0; i<16; i++){
        valArray.outputValArray[i]=(((data[16]>>i)&1)%2)==1? 1 : 0;
        
    }
}




// Set noise
[numthreads(8,8,1)]
void CSInit(uint3 id : SV_DispatchThreadID) {
    bool spawn = (Result[id.xy].x > 0.5);
    Result[id.xy] = spawn ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);
}

//Kernel for Two neighbrohoods
[numthreads(8,8,1)]
void TwoNeighborhoods(uint3 id : SV_DispatchThreadID) {

    //Making sure noises range is okay
    bool spawn = (Result[id.xy].x > 0.5);
    Result[id.xy] = spawn ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);



    float avg[2] = {0, 0};

    for (uint i = 0; i < NeighborhoodBuffer1Size; i++) {
        if (Result[id.xy + NeighborhoodBuffer1[i]].x > 0) {
            avg[0]++;
        }
    }
    for (uint j = 0; j < NeighborhoodBuffer2Size; j++) {
        if (Result[id.xy + NeighborhoodBuffer2[j]].x > 0) {
            avg[1]++;
        }
    }
    avg[0] = avg[0] / NeighborhoodBuffer1Size;
    avg[1] = avg[1] / NeighborhoodBuffer2Size;

    uint outputVal = Result[id.xy].x;



    uint threadRegion= id.x/(width/2) +2*id.y/(height/2)-1;
    
    thresholdsArray thArray;
    outputValueArray valArray;
    
    //Setting regions
    if (threadRegion == 0)
    {
        SetThresholds(thArray, RandomDataBuffer0);
        SetOutputValueArray(valArray, RandomDataBuffer0);
    }
    else if (threadRegion == 1)
    {
        SetThresholds(thArray, RandomDataBuffer1);
        SetOutputValueArray(valArray, RandomDataBuffer1);
    }
    else if (threadRegion == 2)
    {
        SetThresholds(thArray, RandomDataBuffer2);
        SetOutputValueArray(valArray, RandomDataBuffer2);
    }
    else // threadRegion == 3
    {
        SetThresholds(thArray, RandomDataBuffer3);
        SetOutputValueArray(valArray, RandomDataBuffer3);
    }
    



    //this loops checks conditions, using the random data
    for(uint condition = 0; condition < 16; condition += 2) {
        if (avg[condition / 8] >= thArray.thresholds[condition] &&
            avg[condition / 8] <= thArray.thresholds[condition + 1]) {
            outputVal = valArray.outputValArray[condition / 2];
        }
    }


    

    bool inRadius = (distance(float2(mousePosX, mousePosY), id.xy) < 19);

    if (clickedLeft && inRadius) {
        outputVal = 0;
    }
    if (clickedRight && inRadius) {
        outputVal = 1;
    }


    if(Result[id.xy].r==1){
        Result[id.xy] = float4(outputVal, outputVal, 0, 1);
    }else if(Result[id.xy].r==0 && outputVal==1){
        Result[id.xy] = float4(outputVal, 0.0, 0.5, 1);
    }else{
        Result[id.xy] = float4(outputVal, outputVal, outputVal, 1);
    }

    
}

//Kernel for three neighborhoods
[numthreads(8,8,1)]
void ThreeNeighborhoods(uint3 id : SV_DispatchThreadID) {
    //Setting noise 
    bool spawn = (Result[id.xy].x > 0.5);
    Result[id.xy] = spawn ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);


    float avg[3] = {0, 0, 0};

    // Get and set average values for each neighborhood
    for (uint i = 0; i < NeighborhoodBuffer1Size; i++) {
        if (Result[id.xy + NeighborhoodBuffer1[i]].x > 0) {
            avg[0]++;
        }
    }
    for (uint j = 0; j < NeighborhoodBuffer2Size; j++) {
        if (Result[id.xy + NeighborhoodBuffer2[j]].x > 0) {
            avg[1]++;
        }
    }
    for (uint k = 0; k < NeighborhoodBuffer3Size; k++) {
        if (Result[id.xy + NeighborhoodBuffer3[k]].x > 0) {
            avg[2]++;
        }
    }

    avg[0] = avg[0] / NeighborhoodBuffer1Size;
    avg[1] = avg[1] / NeighborhoodBuffer2Size;
    avg[2] = avg[2] / NeighborhoodBuffer3Size;

    uint outputVal = Result[id.xy].x;



    uint threadRegion= id.x/(width/2) +2*id.y/(height/2)-1;
    
    thresholdsArray thArray;
    outputValueArray valArray;
    
    //Setting regions
    if (threadRegion == 0)
    {
        SetThresholds(thArray, RandomDataBuffer0);
        SetOutputValueArray(valArray, RandomDataBuffer0);
    }
    else if (threadRegion == 1)
    {
        SetThresholds(thArray, RandomDataBuffer1);
        SetOutputValueArray(valArray, RandomDataBuffer1);
    }
    else if (threadRegion == 2)
    {
        SetThresholds(thArray, RandomDataBuffer2);
        SetOutputValueArray(valArray, RandomDataBuffer2);
    }
    else // threadRegion == 3
    {
        SetThresholds(thArray, RandomDataBuffer3);
        SetOutputValueArray(valArray, RandomDataBuffer3);
    }
    
    

    // For compactness a loop that has four conditions per neighborhood avg, uses 24 thresholds (2 thresholds * 4 conditions * 3 neighborhoods = 24)
    for (uint condition = 0; condition < 24; condition += 2) {
        if (avg[condition / 8] >= thArray.thresholds[condition] &&
            avg[condition / 8] <= thArray.thresholds[condition + 1]) {
            outputVal = valArray.outputValArray[condition / 2];
        }
    }




    // Mouse logic to kill/birth in a radius
    bool inRadius = (distance(float2(mousePosX, mousePosY), id.xy) < 19);

    if (clickedLeft && inRadius) {
        outputVal = 0;
    }
    if (clickedRight && inRadius) {
        outputVal = 1;
    }

    Result[id.xy] = float4(outputVal, outputVal, outputVal, 1);
}


[numthreads(8,8,1)]
void FourNeighborhoods(uint3 id : SV_DispatchThreadID) {
    //Setting noise 
    bool spawn = (Result[id.xy].x > 0.5);
    Result[id.xy] = spawn ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);


    float avg[4] = {0, 0, 0, 0};

    // Get and set average values for each neighborhood
    for (uint i = 0; i < NeighborhoodBuffer1Size; i++) {
        if (Result[id.xy + NeighborhoodBuffer1[i]].x > 0) {
            avg[0]++;
        }
    }
    for (uint j = 0; j < NeighborhoodBuffer2Size; j++) {
        if (Result[id.xy + NeighborhoodBuffer2[j]].x > 0) {
            avg[1]++;
        }
    }
    for (uint k = 0; k < NeighborhoodBuffer3Size; k++) {
        if (Result[id.xy + NeighborhoodBuffer3[k]].x > 0) {
            avg[2]++;
        }
    }
    for (uint l = 0; l < NeighborhoodBuffer4Size; l++) {
        if (Result[id.xy + NeighborhoodBuffer3[l]].x > 0) {
            avg[3]++;
        }
    }

    avg[0] = avg[0] / NeighborhoodBuffer1Size;
    avg[1] = avg[1] / NeighborhoodBuffer2Size;
    avg[2] = avg[2] / NeighborhoodBuffer3Size;
    avg[3] = avg[3] / NeighborhoodBuffer4Size;



    uint outputVal = Result[id.xy].x;


    
    uint threadRegion= id.x/(width/2) +2*(id.y/(height/2));
    
    thresholdsArray thArray;
    outputValueArray valArray;
    
    //Setting regions
    if (threadRegion == 0)
    {
        SetThresholds(thArray, RandomDataBuffer0);
        SetOutputValueArray(valArray, RandomDataBuffer0);
    }
    else if (threadRegion == 1)
    {
        SetThresholds(thArray, RandomDataBuffer1);
        SetOutputValueArray(valArray, RandomDataBuffer1);
    }
    else if (threadRegion == 2)
    {
        SetThresholds(thArray, RandomDataBuffer2);
        SetOutputValueArray(valArray, RandomDataBuffer2);
    }
    else // threadRegion == 3
    {
        SetThresholds(thArray, RandomDataBuffer3);
        SetOutputValueArray(valArray, RandomDataBuffer3);
    }
    
    

    // For compactness a loop that has four conditions per neighborhood avg, uses 24 thresholds (2 thresholds * 4 conditions * 3 neighborhoods = 24)
    for (uint condition = 0; condition < 32; condition += 2) {
        if (avg[condition / 8] >= thArray.thresholds[condition] &&
            avg[condition / 8] <= thArray.thresholds[condition + 1]) {
            outputVal = valArray.outputValArray[condition / 2];
        }
    }




    // Mouse logic to kill/birth in a radius
    bool inRadius = (distance(float2(mousePosX, mousePosY), id.xy) < 19);

    if (clickedLeft && inRadius) {
        outputVal = 0;
    }
    if (clickedRight && inRadius) {
        outputVal = 1;
    }

    Result[id.xy] = float4(outputVal, outputVal, outputVal, 1);
}


// float[] GetThresholds(uint amountOfNeighboorhoods){
    
//     for(uint i= 0; i<amountOfNeighboorhoods; i++){
            
//     }

// }   


//Remaps an integer 0-127 to 0-1
