#pragma kernel CSInit
#pragma kernel TwoNeighborhoods
#pragma kernel ThreeNeighborhoods

RWTexture2D<float4> Result;

// Screen variables defined in C# script
uint height;
uint width;

StructuredBuffer<uint2> NeighborhoodBuffer1;
StructuredBuffer<uint2> NeighborhoodBuffer2;
StructuredBuffer<uint2> NeighborhoodBuffer3;
StructuredBuffer<uint2> NeighborhoodBuffer4;
StructuredBuffer<uint2> NeighborhoodBuffer5;

uint NeighborhoodBuffer1Size;
uint NeighborhoodBuffer2Size;
uint NeighborhoodBuffer3Size;
uint NeighborhoodBuffer4Size;
uint NeighborhoodBuffer5Size;

// Rule ranges
float slider0;
float slider1;
float slider2;
float slider3;
float slider4;
float slider5;
float slider6;
float slider7;
float slider8;
float slider9;
float slider10;
float slider11;
int slider12;

// Mouse interactions
float mousePosX;
float mousePosY;
bool clickedLeft;
bool clickedRight;

// RANDOM float generator 0-1
float rand(uint3 id) {
    uint2 uv = id.xy;
    float2 noise = frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453);
    return abs(noise.x + noise.y) * 0.5;
}

// Set noise
[numthreads(8,8,1)]
void CSInit(uint3 id : SV_DispatchThreadID) {
    bool spawn = (Result[id.xy].x > 0.5);
    Result[id.xy] = spawn ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);
}

[numthreads(8,8,1)]
void TwoNeighborhoods(uint3 id : SV_DispatchThreadID) {
    float avg[2] = {0, 0};

    for (uint i = 0; i < NeighborhoodBuffer1Size; i++) {
        if (Result[id.xy + NeighborhoodBuffer1[i]].x > 0) {
            avg[0]++;
        }
    }
    for (uint j = 0; j < NeighborhoodBuffer2Size; j++) {
        if (Result[id.xy + NeighborhoodBuffer2[j]].x > 0) {
            avg[1]++;
        }
    }
    avg[0] = avg[0] / NeighborhoodBuffer1Size;
    avg[1] = avg[1] / NeighborhoodBuffer2Size;

    uint outputVal = Result[id.xy].x;

    if (avg[0] >= slider0 && avg[0] <= slider1) {
        outputVal = 1;
    }
    if (avg[0] >= slider2 && avg[0] <= slider3) {
        outputVal = 0;
    }
    if (avg[0] >= slider4 && avg[0] <= slider5) {
        outputVal = 0;
    }

    // Second Neighborhood pass
    if (avg[1] >= slider6 && avg[1] <= slider7) {
        outputVal = 0;
    }
    if (avg[1] >= slider8 && avg[1] <= slider9) {
        outputVal = 1;
    }
    if (avg[1] >= slider10 && avg[1] <= slider11) {
        outputVal = 0;
    }

    bool inRadius = (distance(float2(mousePosX, mousePosY), id.xy) < 19);

    if (clickedLeft && inRadius) {
        outputVal = 0;
    }
    if (clickedRight && inRadius) {
        outputVal = 1;
    }


    if(Result[id.xy].r==1){
        Result[id.xy] = float4(outputVal, outputVal, 0, 1);
    }else if(Result[id.xy].r==0 && outputVal==1){
        Result[id.xy] = float4(outputVal, 0.0, 0.5, 1);
    }else{
        Result[id.xy] = float4(outputVal, outputVal, outputVal, 1);
    }

    if(id.y>slider12){
        Result[id.xy] = float4(1, 1, 1, 1);
    }
}

[numthreads(8,8,1)]
void ThreeNeighborhoods(uint3 id : SV_DispatchThreadID) {
    float avg[3] = {0, 0, 0};

    // Get and set average values for each neighborhood
    for (uint i = 0; i < NeighborhoodBuffer1Size; i++) {
        if (Result[id.xy + NeighborhoodBuffer1[i]].x > 0) {
            avg[0]++;
        }
    }
    for (uint j = 0; j < NeighborhoodBuffer2Size; j++) {
        if (Result[id.xy + NeighborhoodBuffer2[j]].x > 0) {
            avg[1]++;
        }
    }
    for (uint h = 0; h < NeighborhoodBuffer3Size; h++) {
        if (Result[id.xy + NeighborhoodBuffer3[h]].x > 0) {
            avg[2]++;
        }
    }
    avg[0] = avg[0] / NeighborhoodBuffer1Size;
    avg[1] = avg[1] / NeighborhoodBuffer2Size;
    avg[2] = avg[2] / NeighborhoodBuffer3Size;

    uint outputVal = Result[id.xy].x;

    uint thresholds[24];
    uint outputValArray[12];

    // For compactness a loop that has four conditions per neighborhood avg, uses 24 thresholds (2 thresholds * 4 conditions * 3 neighborhoods = 24)
    for (uint condition = 0; condition < 24; condition += 2) {
        if (avg[condition / 8] >= thresholds[condition] &&
            avg[condition / 8] <= thresholds[condition + 1]) {
            outputVal = outputValArray[condition / 2];
        }
    }

    // Mouse logic to kill/birth in a radius
    bool inRadius = (distance(float2(mousePosX, mousePosY), id.xy) < 19);

    if (clickedLeft && inRadius) {
        outputVal = 0;
    }
    if (clickedRight && inRadius) {
        outputVal = 1;
    }

    Result[id.xy] = float4(outputVal, outputVal, outputVal, 1);
}
